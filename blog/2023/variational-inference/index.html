<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Variational Inference | Abhinav Pratap Singh</title> <meta name="author" content="Abhinav Pratap Singh"> <meta name="description" content="Understanding variational inference and applying it to geophysical inversion"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8C%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://ayushinav.github.io/blog/2023/variational-inference/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Abhinav </span>Pratap Singh</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Variational Inference</h1> <p class="post-meta">November 9, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/probability"> <i class="fas fa-hashtag fa-sm"></i> probability</a>   <a href="/blog/tag/inversion"> <i class="fas fa-hashtag fa-sm"></i> inversion</a>   <a href="/blog/tag/geophysics"> <i class="fas fa-hashtag fa-sm"></i> geophysics</a>   <a href="/blog/tag/math"> <i class="fas fa-hashtag fa-sm"></i> math</a>   </p> </header> <article class="post-content"> <h2 id="problem-statement">Problem statement</h2> <p>In geophysical inversion involving uncertainty quantification, we want to calculate the posterior \(p(m|d)\), where \(m\) are the model parameters we want to invert for and \(d\) are the observed data. Given the <em>a priori</em> distribution \(p(m)\) and the likelihood function \(p(d|m)\), the bayesian formulation is</p> \[p(m|d) \propto p(d|m) p(d)\] <p>An obvious candidate to the above problem is MCMC, which has asymptotic convergence guarantees. This however requires a large number of samples. Variational inference turns this inference problem into am optimization one.</p> <h1 id="theory-of-variational-inference">Theory of variational inference</h1> <p>Variational Inference approximates the posterior \(p(m|d)\) with a distribution \(q(m)\), parameterized on, say \(\phi\). Note that \(q(m)\) is still conditioned on \(d\). One would be \(q(m) = \mathcal{N}(\mu(d), \sigma(d)^2)\), where \(\mu\) and \(\sigma\) are the outputs from a network with \(d\) as input and parameterized on \(\phi\). We want \(q\) to be as similar to \(p(m|d)\). In other words, we want the KL divergence \(KL(q(m)|| p(m|d))\) between the two to be as small as possible:</p> \[\begin{aligned} KL(q(m|d)|| p(m|d)) &amp;= \mathbb{E}_{m \sim q(m|d)}\left[\log \frac{q(m|d)}{p(m|d)}\right] \\ &amp;= \mathbb{E}_{m \sim q(m|d)}\left[\log q(m|d)\right]- \mathbb{E}_{m \sim q(m)}\left[\log p(d| m)\right] - \mathbb{E}_{m \sim q(m)} \left[\log p(m)\right] + \mathbb{E}_{m \sim q(m)}\left[\log p(d)\right] \\ &amp;= \mathbb{E}_{m \sim q(m|d)}\left[\log q(m|d)\right]- \mathbb{E}_{m \sim q(m)}\left[\log p(d| m)\right] - \mathbb{E}_{m \sim q(m)} \left[\log p(m)\right] + \log p(m) \\ &amp; (\log p(m) \text{ is marginal and independent of sampling } m) \end{aligned}\] <p>The first three terms on the right hand side constitute the Evidence Lower Bound, or ELBO, defined as:</p> \[\begin{aligned} &amp; \operatorname{ELBO}(q) = \mathbb{E}_{m \sim q(m|d)}\left[\log p(m, d)\right] + \mathbb{E}_{m \sim q(m)}\left[\log p(m)\right] - \mathbb{E}_{m \sim q(m)}\left[\log q(m)\right] \\ \implies &amp; KL(q(m|d)|| p(m|d)) + \operatorname{ELBO}(q) = \log p(m) = \text{Constant} \end{aligned}\] <p>Therefore, maximizing ELBO minimizes the KL divergence. Minimizing ELBO can be done in the following steps:</p> <ul> <li>Sample \(d_i \sim p(d)\)</li> <li> <table> <tbody> <tr> <td>Get \(ELBO(q)\) by sampling $$m \sim q(m</td> <td>d)$$</td> </tr> </tbody> </table> </li> <li>Calculate \(\nabla_{\phi} \operatorname{ELBO}(q)\)</li> <li>Update \(\phi\) using gradient ascent</li> </ul> <h2 id="going-beyond">Going beyond</h2> <p>The theory of variational inference was mostly developed to obtain a parameteric distribution of the observed data variable \(d\) and assuming some latent variable \(m\). The marginal distribution is</p> \[p(d) = \int p(d|m) p(m) dm\] <p>In this case, we do not know what \(p(d|m)\) looks like, and let’s say it’s parameterized on \(\theta\). Let’s have \(q(m)\) again but this time it is to be used as a proposal distribution. For any sample \(d_i\), estimating the likelihood takes the form</p> \[\begin{aligned} \log p_{\theta}(d_i) &amp;= \log \int p_{\theta}(d_i|m)p(m)dm \\ &amp; \text{For any probabilty } q(m) \text { we have}\\ &amp;= \log \int \frac{p_{\theta}(d_i|z)p(m) }{q(m)} q(m)dm \\ &amp;= \log \mathbb{E}_{m \sim q(m)} \left[ \frac{p_{\theta}(d_i|m)p(m)}{q(m)}\right] \\ &amp; \text{Using Jensen's inequality} \\ &amp; \ge \mathbb{E}_{m \sim q(m)} \left[\log \frac{p_{\theta}(d_i|m)p(m)}{q(m)}\right] \\ &amp;= \mathbb{E}_{m \sim q(m)} \left[\log \frac{p_{\theta}(d_i|m)p(m)}{q(m)}\right] \\ &amp;= \mathbb{E}_{m \sim q(m)} \left[\log p_{\theta}(d_i|m)\right] + \mathbb{E}_{m \sim q(m)} \left[p(m)\right] - \mathbb{E}_{m \sim q(m)} \left[\log q(m) \right] \\ &amp;= ELBO(q) \end{aligned}\] <p>THus, the same ELBO becomes a lower bound to the marginal distribution of the observed variable. We now have to optimize with respect to \(\theta\), and minimizing ELBO has one more step:</p> <ul> <li>Sample \(d_i \sim p(d)\)</li> <li> <table> <tbody> <tr> <td>Get \(ELBO(q)\) by sampling $$m \sim q(m</td> <td>d)$$</td> </tr> </tbody> </table> </li> <li>Calculate \(\nabla_{\phi} \operatorname{ELBO}(q)\)</li> <li>Update \(\phi\) using gradient ascent</li> <li>Calculate \(\nabla_{\theta} \operatorname{ELBO}(q)\)</li> <li>Update \(\theta\) using gradient ascent</li> </ul> <h2 id="nabla_theta-operatornameelboq">\(\nabla_\theta \operatorname{ELBO}(q)\)</h2> <p>While all the steps looked fairly simple until now, there are a few nitty gritties. For a sample</p> <ul> <li>Sample \(d_i \sim p(d)\) \(d_i \sim p(d)\), we pass it throught the network to obtain \(q_\phi(m|d)\), eg., the network outputs the mean and variance of a normal distribution. Before any optimization, \(\phi\) is initialized in any way.</li> <li> <table> <tbody> <tr> <td>Get \(ELBO(q)\) by sampling $$m \sim q(m</td> <td>d)$$</td> </tr> <tr> <td>Sampling a few samples from $$q(m</td> <td>d)$$, the expectaion can be estimated.</td> </tr> </tbody> </table> </li> <li>Calculate \(\nabla_{\phi} \operatorname{ELBO}(q)\)</li> <li>Update \(\phi\) using gradient ascent</li> <li>Calculate \(\nabla_{\theta} \operatorname{ELBO}(q)\) We note that only the first term here is dependent on \(\theta\). \(p(m)\) is the <em>a priori</em> distribution of \(m\) and \(q(m|d)\) is parameterized on \(\phi\). For one sample, say \(m^*\), we pass it through the network to obtain the distribution \(p_\theta(d|m)\), we can easily differentiate through \(\theta\), using backpropagation.</li> <li>Update \(\theta\) using gradient ascent</li> </ul> <h2 id="nabla_phi-operatornameelboq">\(\nabla_\phi \operatorname{ELBO}(q)\)</h2> <p>Most of the steps are similar as above until we get to the point where we have to calculate \(\nabla_\phi \operatorname{ELBO}(q)\). The first thing we notice is we have to differentiate through the sampling process. To compute this, we make use of the reparameterization trick. This means we assume another variable \(\tilde{m}\) such that we can write</p> \[m \sim q_\phi(m) \Longleftrightarrow m = g_{\phi}(\tilde{m}) \quad \text{where} \quad \tilde{m} \sim h(\tilde{m})\] <p>This is better understood via an example. Let \(q(m)\) be \(\mathcal{N}(\mu, \sigma^2)\), then defining \(\tilde{m} \sim \mathcal{N}(0, 1)\)</p> \[m \sim \mathcal{N}(\mu, \sigma^2) \Longleftrightarrow m = \mu + \sigma \tilde{m} \quad \text{where} \quad \tilde{m} \sim \mathcal{N}(0, 1)\] <p>This way, we can sample from \(\tilde{m}\) to get the samples from the same distribution as \(m\). We, therefore, sample \(\tilde{m}\) and not \(m\). The ELBO takes the form</p> \[\begin{aligned} \operatorname{ELBO}{q} &amp;= \mathbb{E}_{m \sim q(m)}\left[ logp_\theta{d_i|m} + p(m) - log q(m) \right] \\ &amp;= \mathbb{E}_{\tilde{m} \sim h(\tilde{m})}\left[ logp_\theta{d_i|g_{\phi}(\tilde{m})} + p(g_{\phi}(\tilde{m})) - log q(g_{\phi}(\tilde{m})) \right] \\ \end{aligned}\] <p>We can now differentiate through the expression w.r.t \(\phi\), in the similar way as we did for \(\theta\). To summarize, the training process transforms into:</p> <ul> <li>Sample \(d_i \sim p(d)\) <br> \(d_i \sim p(d)\), we pass it throught the network to obtain \(q_\phi(m|d)\). Sample from \(q_{\phi}(m)\) using the reparameterization trick.</li> <li> <table> <tbody> <tr> <td>Get \(ELBO(q)\) by sampling $$m \sim q(m</td> <td>d)$$ \</td> </tr> <tr> <td>Sampling a few samples from $$q(m</td> <td>d)$$, the expectaion can be estimated.</td> </tr> </tbody> </table> </li> <li>Calculate \(\nabla_{\phi} \operatorname{ELBO}(q)\) <br> Get the gradient using backpropagation using the reparameterization trick.</li> <li>Update \(\phi\) using gradient ascent</li> <li>Calculate \(\nabla_{\theta} \operatorname{ELBO}(q)\) <br> We note that only the first term here is dependent on \(\theta\). \(p(m)\) is the <em>a priori</em> distribution of \(m\) and \(q(m|d)\) is parameterized on \(\phi\). For one sample, say \(m^*\), we pass it through the network to obtain the distribution \(p_\theta(d|m)\), we can easily differentiate through \(\theta\), using backpropagation.</li> <li>Update \(\theta\) using gradient ascent</li> </ul> <h2 id="for-geophysical-inversion">For geophysical inversion</h2> <p>The implementaion for probabilistic geophysical inverse problems is fairly similar. In this domain, we have the observed data \(d\) and its error bars, generally the standard deviation associated with each data point.</p> \[\begin{aligned} p(m|d) &amp; \propto p(d|m)p(m) \\ posterior \; distribution &amp; \propto likelihood * prior \; distribution \end{aligned}\] <p>The likelihood is generally the negative exponential of the misfit between the observed data and the forward response from a given model, that is</p> \[p(d|m)= \exp \left[- (\mathcal{F}(m)- d)^T W (\mathcal{F}(m)- d) \right]\] <p>where \(\mathcal{F}\) is the forward model operator and \(W\) is the weight matrix, usually the inverse of the variance in the data. The prior distribution is something where the <em>a priori</em> knowledge comes in. If in the misfit term, we were supposed to have a regularizer, say \(\| m - m_0\|^2\) for a reference model \(m_0\), then it manifests in the <em>a priori</em> distribution as</p> \[p(m)= \exp \left[- \| m - m_0\|^2 \right]\] <p>Which is just a scaled gaussian with unit variance. The posterior then becomes</p> \[p(m|d) \propto \exp \left[- (\mathcal{F}(m)- d)^T W (\mathcal{F}(m)- d) \right] \exp \left[- \| m - m_0\|^2 \right]\] <p>As is evident, we do not have to parameterize using \(\theta\). We again assume \(q_{\phi}(m)\) to approximate this posterior using variational inference. This we parameterize on \(\phi\), which can be just the parameters of the family of distribution we are using to approximate the posterior, or the weights of the network.</p> <h2 id="constraints-structure">Constraints/ Structure?</h2> <p>While constraints are included in the <em>a priori</em> term, it is worth noting that the approach to a lot of geophysical inverse problems assume that the model parameters bear no correlation with each other. However, a decent approach would have a way to incorporate structure. The mean field approximation assumes that the model parameters do not bear any correlation with each other. Would it be possible to do that by including that in the regularizer, that is the <em>a priori</em>, similar to what happens in <a href="https://marineemlab.ucsd.edu/~steve/bio/Occam1D.pdf" rel="external nofollow noopener" target="_blank">Occam 1D</a>, and RTO-TKO?</p> <p>OR we still sample them independently, but use a mapping that enforces the structure that is then passed into the forward operator? Remember that constraints in deep learning are applied via a similar idea, eg., using the softmax function as the last layer of the neural network to output probabilities.</p> <h1 id="references">References</h1> <ul> <li><a href="https://arxiv.org/abs/1601.00670#:~:text=One%20of%20the%20core%20problems,calculation%20involving%20the%20posterior%20density." rel="external nofollow noopener" target="_blank">Variational Inference: A Review for Statisticians</a></li> <li><a href="https://youtu.be/iL1c1KmYPM0" rel="external nofollow noopener" target="_blank">Stanford CS330: Variational Inference and Generative Models: Lecture 11</a></li> <li><a href="https://youtu.be/-hcxTS5AXW0" rel="external nofollow noopener" target="_blank">2021 3.1 Variational inference, VAE’s and normalizing flows - Rianne van den Berg</a></li> </ul> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Abhinav Pratap Singh. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id="></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>